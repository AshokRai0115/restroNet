// services/cbf-pipeline.js

// --- 1. MODEL IMPORTS (Ensure correct relative paths and CommonJS syntax) ---
// Adjust paths as necessary based on your project structure
const Venue = require('../models/venueModel'); 
const Cuisine = require('../models/cuisineModel'); 
const RestaurantFeatures = require('../models/featureModel'); 

// --- 2. GLOBAL CBF CONFIGURATION (Loaded from DB) ---
// These variables define the fixed dimensions of your feature vectors.
let GLOBAL_CUISINE_MAP = {}; // Map: {'Italian': 0, 'Chinese': 1, ...}
let TFIDF_VOCABULARY = {}; // Map: {'truffle': 0.1, 'patio': 0.05, ...}

// Fixed bounds for Min-Max Scaling
const RATING_MIN = 1; 
const RATING_MAX = 5; 

/**
 * Loads and initializes the necessary global configurations for OHE and TF-IDF.
 * This runs at the start of every feature calculation to ensure current dimensions.
 */
async function loadCbfConfig() {
    try {
        // --- 1. Load OHE Order/Map (Fixed Cuisines) ---
        // Sorting by 'name' ensures the vector order is consistent across all runs.
        const cuisines = await Cuisine.find().sort({ name: 1 }).select('name');
        
        // Build the Map: Key = Cleaned Cuisine Name, Value = Vector Index
        GLOBAL_CUISINE_MAP = cuisines.reduce((acc, cuisine, index) => {
            // Use .trim() to match the cleaning done on the venue's cuisine array
            const name = cuisine.name ? cuisine.name.trim() : null; 
            if (name) {
                acc[name] = index;
            }
            return acc;
        }, {});

        
        // --- 2. Load TF-IDF Vocabulary (Conceptual) ---
        // NOTE: In a production system, this would load a persistent file (e.g., JSON)
        // containing the vocabulary and inverse document frequency (IDF) scores 
        // generated by a separate, nightly training script.
        
        // For now, we assume this is pre-populated or empty for a new system.
        // TFIDF_VOCABULARY = await loadTfidfModelVocabulary(); 

    } catch (error) {
        console.error("FATAL ERROR: Failed to load CBF Configurations.", error);
        // Throwing the error here will halt the pipeline and prevent a bad vector generation.
        throw new Error("Configuration Load Failed.");
    }
}

/**
 * Calculates and updates the feature vector for a single venue.
 * @param {mongoose.Types.ObjectId} venueId - The ID of the newly created venue.
 */
async function triggerFeatureRecalculation(venueId) {
    try {
        await loadCbfConfig(); // Load global config first
        
        // 1. Fetch the raw venue data
        const venue = await Venue.findById(venueId); 
        
        if (!venue) {
            console.warn(`CBF: Venue ${venueId} not found.`);
            return;
        }

        // --- A. Calculate OHE Cuisine Vector (Multi-Label) ---
        const venueCuisines = venue.cuisine || [];
        const cuisineVectorLength = Object.keys(GLOBAL_CUISINE_MAP).length;
        const cbf_cuisine_vector = new Array(cuisineVectorLength).fill(0);
        
        if (Array.isArray(venueCuisines) && venueCuisines.length > 0) {
            venueCuisines.forEach(rawCuisineName => {
                const cleanedCuisineName = rawCuisineName ? rawCuisineName.trim() : null;
                
                if (cleanedCuisineName && GLOBAL_CUISINE_MAP.hasOwnProperty(cleanedCuisineName)) {
                    const index = GLOBAL_CUISINE_MAP[cleanedCuisineName];
                    cbf_cuisine_vector[index] = 1; // Set the corresponding bit to 1
                }
            });
        }
        

        // --- B. Calculate TF-IDF Tags Vector (Conceptual) ---
        // If TFIDF_VOCABULARY is empty, this vector will be empty/all zeros.
        const tagsVectorLength = Object.keys(TFIDF_VOCABULARY).length;
        const cbf_tags_vector = new Array(tagsVectorLength).fill(0);

        if (venue.tags && Array.isArray(venue.tags) && tagsVectorLength > 0) {
             venue.tags.forEach(tag => {
                // Ensure the tag is in the global vocabulary
                if (TFIDF_VOCABULARY.hasOwnProperty(tag)) {
                    const index = Object.keys(TFIDF_VOCABULARY).indexOf(tag);
                    const idf_score = TFIDF_VOCABULARY[tag];
                    // TF is simplified to 1 for term presence * IDF score
                    cbf_tags_vector[index] = idf_score; 
                }
             });
        }
        
        // --- C. Calculate Scaled Rating Score ---
        const rawRating = venue.average_rating || 0;
        let cbf_rating_score = (rawRating - RATING_MIN) / (RATING_MAX - RATING_MIN);
        
        // Clamp the score to the [0, 1] range to prevent negative scores
        if (cbf_rating_score < 0) cbf_rating_score = 0;
        if (cbf_rating_score > 1) cbf_rating_score = 1;
        
        
        // --- D. Upsert Features Document ---
        const features = await RestaurantFeatures.findOneAndUpdate(
            { restaurant: venueId },
            {
                $set: {
                    cbf_cuisine_vector,
                    cbf_tags_vector,
                    cbf_rating_score,
                    last_calculated: new Date()
                }
            },
            { upsert: true, new: true } // Creates or updates the document
        );

        console.log(`CBF Pipeline SUCCESS: Features created/updated for Venue ${venueId}.`);
        return features;

    } catch (error) {
        // This catch block is ESSENTIAL for debugging asynchronous failures
        console.error(`CBF Pipeline CRITICAL ERROR for Venue ${venueId}:`, error.message, error.stack);
        // Note: The main controller will still return 201, but the error is logged here.
    }
}

// Export the main function using CommonJS syntax
module.exports = {
    triggerFeatureRecalculation,
    // You might export loadCbfConfig for manual testing/reloading
    loadCbfConfig
};